##상속(Inheritance)

### 8.1 정의 : 
- 두 개 이상의 클래스에서 부모(상위)와 자식(하위)의 관계를 도출하여 표현됨.
- 자식의 클래스에서 extends(소문자로 써야함) 키워드를 통해 상속 관계를 생성함.
- 자식의 생성자 호출 시 부모 객체가 생성된 후 자식의 객체가 생성됨
- 자바의 모든 클래스는 java,lang.object 클래스의 자식 클래스됨.
- 자바는 단일 상속만 가능함. 다중 상속은 불가능하다.


### 8.2  상속의 표현

public class [자식 클래스] extends [부모 클래스] {
	Field
	Constructor
	Method
}

### 8.3 자료의 상속(~~= 필드)의 상속
-자식의 객체를 생성 시 부모와 같은 필드가 존재하면, 자식의 필드가 우선적으로 호출됨.
-이 경우 부모의 필드는 호출되지 않는다.(예외도 없다. 무조건 자식 필드 우선)
- 부모가 가지고 있는 필드는 상속하는 경우 자식이 정의하지 않음!!
- 자료의 상속은 가능하지만 권장하지는 않으므로 크게 사용하지 않는다.

### 8.4 메소드의 상속 - 주의깊게 볼것
- 자바의 상속은 "다양성의 구현과 행위 중심의 설계"에 있다!!!.
- 메소드의 상속은 부모가 가지고 있는 메소드를 자식이 상속받아 구현됨을 의미한다.
- 부모와 자식이 동일한 이름의 메소드를 정의한 경우, 자식의 메소드만 호출됨.
- 부모 클래스의 메소드를 모든 자식들이 똑같이 상속받아 구현되는 경우는, 메소드의 오버라이딩 개념을 적용함.

### 8.5 메소드 오버라이딩(Overriding)
- 객체 지향의 개념 중 다형성(Polymerphism)을 코드로 적용한 개념.(하나의 이름, 다양한 모습)
- 부모의 메소드를 자식이 상속받아 다양한 모습으로 구현하는 방식.
  일반 클래스(부모) -> 오버라이딩 선택 가능(자식) - 메소드를 같은이름으로 만들어도 되고 아니어도 된다.
  추상 클래스(부모) -> 오버라이딩 무조건 진행(선택 불가)(자식은 오버라이팅 필수.)
- 메소드의 오버 라이딩은 부모의 메소드를 동일하게 구현하는 방식임.
(메소드명/ 매개변수/ 리턴타입 모두를 동일하게 구현해야함);
-상속 관계에서 자식이 부모의 메소드를 오버라이딩하는 경우 @Override 어노테이션(Annotation)을 붙어줌.
	안붙여도 상관은 없는데, 안붙여두면 나중에 수정할때나 다른사람이 이어받을때 굉장히 불편해짐. 붙여둘것.



### 8.5 상속과 생성자 호출
- 상속관계에서 자식의 생성자보다 부모의 생성자가 먼저 호출됨
- super() 메소드를 이용하여 오버로딩된 부모의 생성자를 호출할 수 있음.
- this(), super() 메소드는 생성자 정의 시 첫 행에 정의되어야 함.

###실습 예제
강남 병원은 사람들의 건강검진을 진행하는 병원이다. 이 병원을 확정하여 동물병원을 설립하고자 한다.
이때, 시스템은 통합하여 하나의 프로그램으로 구현하고자 한다.
여기에 맞는 클래스들을  도출해보자. 동물병원은 강아지,고양이가 고객이 된다.

사람[PerSon] = 나이,이름,주소, 전화번호
동물[Animal] = 나이,이름,Person
고객[Client] = 나이,이름

--부모와 자식 관계 도출
고객 클래스 has a 사람 클래스(O) =>고객 클래스 (부모) / 사람클래스(자식)
고객 클래스 has a 동물 클레스(0) =>고객 클래스 (부모) / 동물클래스(자식)

public class 고객 (client){}
public class 사람(person) extend 고객(Client){}
public class 동물(animal) extend 고객(Client){}

public class 고객(client){
	String name;
	int age;}

public class 사람(Person) extends 고객(Client)
{
	//String name; - 부모인 고객 클래스에 있어서 제외
	//int age;
	String address;
	String phone;
	}

public class(동물) extends 고객(client)
{
	//String name; - 부모인 고객 클래스에 있어서 제외
	//int age;	
	Person owner;
}
	
	
Client c1 = new Client()
Person p1 = new Person();

저장위치(힙영역)에 부모가 있는 경우 부모를 먼저 만들고 이후 자기 자신을 만든다.
참고로 부모는 자기만의 부모가 따로 생성된다.
위의 예시 Person p1 = new Person(); 를 보면 순서는 다음과 같다.
1. p1을 stack 영역에 생성한다.
2. new Person();을 실행하기 위해 Person 클래스를 보면 public class 사람(Person) extends 고객(Client)이다.
즉, 이 경우에는 Client(고객)이라는 부모 클래스가 존재하기 때문에 Person을 Heap영역에 생성하기 전에 Client 영역을 우선 생성한다.
3. 이후 Person()을 Heap영역에 생성한다.

그리고 변수에 데이터를 저장할 경우 자식에 저장한다.
EX) p1.name = "홍길동" 이면 이것은 heap공간 에서 Person.name 에 들어가게 된다.(부모한테는 안간다)

현재는 자식 변수만 접근이 가능하다.(부모가 가진 같은 이름의 변수에는 접근하지 못한다.)

추상 클래스에서 추상 메소드로 인해서 클래스 내부의 변수를 사용하는것이 불가능하다.
이에 추상 메소드만 뽑아내는데, 이게 인터페이스다.

내일할꺼 (내일 = 7.15)

### 8.6 객체의 형변환
(과거 기본 데이터 타입 형변환 했었다-3장.)

 - 상속 관계의 객체들 사이에서 이루어지는 형변환을 의미함.
 - 부모 클래스가 자식 클래스 타입으로 객체를 생성한 경우에 형변환이 이루어짐.
예) 부모(상위)클래스 참조변수 = new 자식(하위) 생성자();
	어제의 예시 : 기존 - Circle redC = new Circle();
	Shape greenC = new Circle(); //greenC객체는 명시적 형변환의 대상이 됨
-   Circle C = (Circle)greenC // greenC객체는 Circle을 포함하고 있으므로 형변환이 가능하다.
	또는 ShapeInterface blueC = new Circle();
	
Shape s2 = new Shape("빨강");
	Circle cs2 = (Circle)s2;//"강제(명시적) 형변환 불가"
	S2 객체는 Circle을 포함하고 있지 않기 때문임.

- 인터페이스를 통한 형변환! - 자바에서 강력하게 권장하는 형태(실무)
- 구현되는 클래스에 의존하지 말고, 인터페이스에 의존해서 개발을 해라!

- 인터페이스를 중심으로 설계하고 구현하는 프로그램을 작성해주세요!!
예시 : Circle 클래스 생성(구현)
Circle C = new Circle();


실무에서 많이 사용되며 권장하는 스타일!
ShapeInterface si = new Circle();
리모콘 a = new 삼성리모콘();



 
