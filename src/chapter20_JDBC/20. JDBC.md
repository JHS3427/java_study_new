## 20. JDBC(JAVA DataBase Connectivity) - java.sql.

### 1. JDBC API를 이용한 연결 단계!!! - 4번째 드라이버 타입. : thin 형태의 드라이버 형식
0.드라이버 준비 - MYSQL	 사이트에서 드라이버 다운로드.-->mysql-connectro~~.jar파일을 bulid path에 추가

구체적인 순서 :  MYSQL	 사이트에서 드라이버 다운로드.->해당 zip에서 jar파일을 java_study_new의 lib 폴더에 옮겨넣는다.->java_study_new 우클릭 > bulid path>configure bulid path>libraries탭에서 jar 파일 add jar 하고 apply.



1.드라이버 로딩 - DriverManager
2.connection 생성. - Connection
3.statement 생성 - Statement, PrepareStatement
4.resultset 생성 - ResultSet
5.sql 실행 및 결과 생성 - 3번, 4번 객체를 사용
6.close - 생성한 모든 객체 종료

-		JAVA(JVM)<--------------------------> MYSQL과 연결(ORACLE,DB2,MS-SQL)
접속에 필요한거 : 				드라이버. - 일반적으로 우측의 프로그램 업체가 준비해둠.


~~ VO : DB에서 받아온 데이터 1줄1줄 받는 클래스에 붙임.
		DB의 필드값들 선언하고 getter/setter 함수 만들어두는 클래스.
		VO = DTO 다. 옛날에쓰던게 DTO, 최근께 VO.
~~DAO 기준 : 테이블에 CRUD 해주는 클래스. EX : employeeDAO : employee 테이블에 CRUD 해주는 클래스.
이때, 어차피 crud하려면 접속(1단계), 접속끊기(5단계)는 모두 공통으로 해야하니 이건 하나로 묶어서 상속받는다.

---
전체적인 코딩 순서

1. connection = DriverManager.getConnection(url,user,password)
2. statment = connection.createStatement();
또는 preparedstatement 쓰자
	getPreparedStatement = connection.prepareStatement(sql);
3. 받아온 데이터를 처리.
4. close로 닫기.

구체적인 순서
1. 0) DriverManager import하기.
1. 1) url : "jdbc::mysql://localhost:3306/hrdb2019" =>"jdbc::내db프로그램://주소:포트/db명"
1. 2) user, password : 기존에 쓰던거 그대로.

2. 0) connection, Statement, PreparedStatement import 하기, 셋다 Field에 변수 선언해두기.
2. 1) Statement stmt = connection.Statement();
2. 2) PreparedStatement pstmt = connection.prepareStatement(sql);

3. 0) ResultSet import 하고 ResultSet 변수 Field에 선언해두기
3. 1) ResultSet 변수 = Statement변수.executeQuery(sql); 로 저장 후 이거로 작업진행.


같은 내용의 함수지만 사용하는 클래스가 달라서 클래스별로 만드는 것은 비효율적이고, 다형성에 어긋난다.
따라서 인터페이스에서 해당 부분을 처리할 수 있다.

인터페이스명 <T> - 인터페이스에서 선언할 때에는 클래스 자리에 T를 넣고 사용시에는 해당 T 자리에 클래스를 넣는다.
예: newInterface<T>
List<T> list(); -> 클래스에서 사용할 때 : List<MemberVo> list() = new ArrayList<MemberVo>


Application 실행(MgmSystem)후 클릭> ScoreService >Repository > DB > Repository > ScoreService 순서

이때 interface를 쓰는 이유 : Repository나 ScoreService가 지금은 1종씩이지만 다른 DB테이블을 연동하게되면 여러개가 될꺼다. 그때마다 함수명 새로 만들면 복잡해지니까 통일성을 위해서 인터페이스로 묶는다.


8/1일

GUI(화면/웹) <-> ServiceImpl <-> repositoryImpl(= DAO = DTO) <->DB(Impl 있으면 보통 자식이다).
		Model(VO)	  ^		~VO			^
			ServiceInterface	RepositoryInterface
						둘다 Override필요
Model(VO) = 데이터를 가진 객체.

위의 Service나 repository는 DB 테이블 1개당 보통 1개씩 생긴다.
이때 service와 repository를 하나로 묶어서 만들지 않는 이유
: 사용자와 프로그래머 간 사용과 구성의 차이때문.
예시 : GUI에서 마이페이지/로그인/회원가입 이라는 3가지 서비스가 있을 수 있지만, 이걸 DB에서 처리할때는 1개만 있을 수 있다. 즉, Service는 3개지만, Repository는 1개면 된다.
즉, 사용자와 프로그래머 간 기능적 차이가 존재해서 둘을 나눠놓는거다.

인터페이스에서 정의한 메소드(A)가 있다.
이때, 해당 인터페이스를 implements한 클래스(CA)가 있고, 해당 클래스에서 인터페이스에서 정의한 A를 구체화(A`) 시켰다고 가정하자.
이후 해당 인터페이스를 implements하는 클래스(CB)가 있을때, CB는 CA에서 선언하여 구체화한 A`를 그대로 가져다 쓸 수 있다.

오늘 연습한 bookmgm
1. 강사님이 맨처음 시키실 땐, DB마다 각각 Repository 자바 파일을 만들었다.
2. 그런데 어차피 같은거 처리하는거 아니냐고 여쭤봤더니, 업체마다 다를걸 고려해서 여러개로 만든다고 하셨었다.
3. 하지만 수업 시작하시면서 합치는쪽으로 갔다.

--> 최종적으로는 시작할 때, 업체 선택하면 그걸 Service에서 받고, 특정 수치를 Repository로 넘긴다. 그걸 보고 
tableName이라는 변수를 받는 값에 따라 바꿔서 sql문 만들때 넣어준다.